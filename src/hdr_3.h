/**
 * @file hdr_3.h
 * @brief Краткое описание заголовка.
 * Действие команды \p \@brief продолжается до следующей команды. Doxygen
 * автоматически слепит все строки в один абзац. Doxygen генерирует типовую структуру
 * для каждого документируемого файла. Даже краткое описание разбивается на две части:
 * первый абзац краткого описания и последующие абзацы краткого описания.
 * 
 * Чтобы начать новый абзац, пропустите строку. Обычно в кратком описании
 * приводится аннотация. Первый абзац аннотации Doxygen размещать в других частях
 * документации, чтобы пояснить, для чего этот файл.
 * 
 * @note _Следует обратить внимание на следующие моменты:_
 *  - Важно, чтобы аргумент команды \p \@file совпадал с именем файла, чтобы Doxygen
 * корректно его добавил в свой индекс.
 *  - Если вы документируете глобальные объекты программы (функции, переменные, перечисления, типы),
 * то в файле их определения команду \p \@file нужно <u><i>обязательно</i></u> использовать (один раз
 * в начале файла).
 * @version 0.1
 *
 * @section h1_sec_0 Детальное описание
 * Рекомендуется начинать детальное описание с заголовка, но это не обязательно.
 * Заголовок помогает понять, где заканчивается аннотация. Заметим, что Doxygen
 * игнорирует любые переносы строк в комментарии, заменяя их пробелом, а также
 * заменяются множественные пробелы на один пробел.
 *  
 * В абзаце можно делать переносы строк произвольно с помощью тега \p \<br\>, либо
 * с помощью символа \p \\n. Например,\nновая строка в том же абзаце<br>и еще строка
 * в том же абзаце.
 * 
 * Вы можете пометить начало подробного описания с помощью команды \p \@details,
 * однако это необязятельно, так как команда \p \@version не поддерживает многострочный
 * аргумент, а пустая строка фактически дает понять Doxygen, что началось детальное
 * описание. Если вы разместите технологическую информацию типа версия, автор, копирайт и др.,
 * выше краткого описания, то \p \@details нужно использовать, чтобы Doxygen понял,
 * где заканчивается \p \@brief. Обратите внимание, что одиночный символ \p \@ зарезервирован
 * Doxygen, поэтому его нужно экранировать. 
 *
 * Вообще пустые строки помечают начало нового абзаца. Подробное описание
 * распространяется до конца этого комментария, либо до следующей команды,
 * не являющейся командой секционирования текста. Когда Doxygen просматривает
 * файл, он как бы объединяет все комментарии для Doxygen в один большой комментарий,
 * поэтому вы можете их разбивать. Обычно это происходит, когда комментарий
 * доходит до исходного кода программы.
 *
 * Начиная с версии Doxygen 1.8 вы можете использовать Markdown-разметку
 * в комментариях. Это обычно нагляднее, чем команды Doxygen, которые
 * занимаются тем же.
 *
 * ## Заголовок второго уровня на языке Markdown {#anchor_1}
 * 
 * К сожалению, заголовки, которые встраиваются в шаблон страницы Doxygen, не учитывают
 * уровни заголовков шаблона, поэтому они могут выглядеть по размеру немного больше чем нужно.
 * 
 * Рекомендуется ко всем заголовкам Markdown создавать якори { #имя_якоря}. По ним вы можете
 * делать перекрестные ссылки командой \p \\ref. Это расширение Doxygen - в стандартном Markdown его нет.
 * 
 * Также якоря можно рассталять в любой части документации с помощью команды \p \\anchor.
 * 
 * Абзац под заголовком второго уровня. *Курсив*, **Полужирное начертание**,
 * ~~зачеркнутый~~, __Полужирный__, _Курсив_.
 * 
 * Исторически нумерованные списки в Doxygen создаются с помощью символа `-#`,
 * поэтому рекомендуется использовать именно его, во всех комментариях для
 * Doxygen. Однако не запрещено использовать цифру с точкой как в оригинальном
 * синтаксисе Markdown (однако, в этом случае не будет автоматического инкремента).
 *
 * -# Яблоко
 * -# Помидор
 *    -# Лук
 *    -# Ананас
 * -# Огурец
 * 
 * Для маркированного списка рекомендуется использовать не `*`, а символ `-`, хотя современные
 * версии Doxygen корректно распознают символ `*`, если он начинает строку без первой звездочки
 * баннера.
 *
 * - Первый элемент
 * - Второй элемент
 *   - Вложенный элемент
 * - Третий элемент
 *
 * Одноуровневые списки можно создавать также командой \p \\arg. \n
 * \arg Яблоко
 * \arg Апельсин
 * \arg Ананас
 * 
 * ```cpp
 * int main(int argc, char* argv[])
 * {
 *     return 0;
 * }
 * ```
 * > Это цитата на языке
 * > Markdown.
 * \anchor create_table
 * Таблицы в документации рекомендуется составлять на языке Markdown, потому что так
 * проще. Doxygen поддерживает расширения таблиц с объединением ячеек и по столбцам и по
 * строкам.
 * 
 * _Таблица 1._ Простая таблица
 * |Колонка 1|Колонка 2|Колонка 3|
 * |:-------:|:-------:|:-------:|
 * |Ячейка 11|Ячейка 12|Ячейка 13|
 * |Ячейка 21|Ячейка 22|Ячейка 23|
 * |Ячейка 31|Ячейка 32|Ячейка 33|
 * 
 * _Таблица 2._ Таблица с объединенными ячейками по строке
 * |Колонка 1|Колонка 2|Колонка 3|
 * |:-------:|:-------:|:-------:|
 * |Ячейка 11|Ячейка 12|Ячейка 13|
 * |Ячейка 21|Ячейка 22|Ячейка 23|
 * |Ячейка 31|||
 * 
 * _Таблица 3._ Таблица с объединенными ячейками по столбцу
 * |Колонка 1|Колонка 2|Колонка 3|
 * |:-------:|:-------:|:-------:|
 * |Ячейка 11|Ячейка 12|Ячейка 13|
 * |Ячейка 21|Ячейка 22|Ячейка 23|
 * |^|Ячейка 32|Ячейка 33|
 * 
 * Таблицу можно сформировать и в чистом _HTML_-коде, но для этого нужна сноровка.
 * 
  * _Таблица 4._ Сложная таблица
 *  <table> 
 *    <tr><th>Column 1   <th>Column 2 <th>Column 3 
 *    <tr><td rowspan="2">cell row=1+2,col=1
 *        <td>cell row=1,  col=2<td>cell row=1,col=3 
 *    <tr>
 *        <td rowspan="2">cell row=2+3,col=2 
 *        <td>cell row=2,  col=3 
 *    <tr>
 *        <td>cell row=3,col=1 
 *        <td rowspan="2">cell row=3+4,col=3 
 *    <tr>
 *        <td   colspan="2">cell row=4,col=1+2 
 *    <tr>
 *        <td>cell row=5,col=1 
 *        <td colspan="2">cell   row=5,col=2+3 
 *    <tr>
 *        <td colspan="2" rowspan="2">cell row=6+7,col=1+2 
 *        <td>cell   row=6,col=3 <tr> <td>cell row=7,col=3 
 *    <tr>
 *        <td>cell row=8,col=1 
 *        <td>cell row=8,  col=2\n
 *    <table> 
 *      <tr>
 *          <td>Inner cell row=1,col=1
 *          <td>Inner cell row=1,col=2   
 *      <tr>
 *          <td>Inner cell row=2,col=1
 *          <td>Inner cell row=2,col=2 
 *    </table> 
 *    <td>cell   row=8,col=3 
 *    <ul> <li>Item 1 <li>Item 2 
 *    </ul> 
 *  </table>
 * 
 * \section h1_sec_1 Заголовок секции
 * Мы создали раздел через внутреннюю команду Doxygen. У этой команды первый аргумент определяет
 * метку заголовка (он должен быть уникален, потому что по нему могут быть созданы перекрестные ссылки),
 * а второй - отображаемый текст.
 * Внутренние команды секционирования Doxygen копируют команды LaTeX. Вы должны помнить,
 * что как в LaTeX Doxygen следит (но не так строго) за иерархией команд секционирования.
 * Т.е. нельзя вложить секцию в подраздел и т.п.
 *
 * \subsection h1_sec_sec_1 Подраздел
 * Текст подраздела.
 *
 * \subsubsection h1_sec_sec_sec_1 Подподраздел
 * Текст подподраздела.
 *
 * Для форматирования текста можно использовать следующие команды:
 * -# \a Курсив или \e Курсив
 * -# \b Полужирное \b начертание
 * -# \c Моноширинный или \p Моноширинный 
 * -# Вставка эмотикона \emoji :smile:
 * -# <s>зачеркнутый</s>
 * -# <u>подчеркнутый</u>
 * -# Специальные символы: \| \$ \& \# \< \> \% \" \. \:: \= -- ---
 *
 * Все команды форматирования действуют до первого пробела, но если вы возьмете
 * словосочетание в кавычки, то команда применится до закрывающей кавычки.
 * Например, \b "этот текст будет использовать полужирное начертание".
 * 
 * Для создания блоков с кодом можно использовать блок \p \\code ... \p \\endcode. Для лучшей
 * наглядности, рекомендуется подписывать блоки кода, тогда они будут выделяться
 * на фоне текста (если конечно блоки не являются частью абзаца).
 * 
 * > _Демонстрация команды `echo`_
 * > \code{.sh}
 * > echo "Hello, World!"
 * > \endcode
 *
 * \paragraph h1_sec_sec_sec_sec_1 Перекрестные ссылки
 * Самый нижний уровень секционирования.
 * 
 * Очень полезная вещь, которую делает Doxygen, это перекрестные ссылки. Вы можете сосласться
 * на любую часть документации, на которую создана метка. Если вы создаете заголовки командами
 * Doxygen, то у них всегда есть метка. Если Doxygen не может разрешить ссылку по метке, то будет просто отображен
 * введенный после команды текст.
 * 
 * Рассмотим следующие полезные примеры:
 * \arg _Ссылка на заголовок в том же файле:_ \ref h1_sec_0 (перекрестная ссылка на самую первую секцию этого документа)
 * \arg _Ссылка на заголовок в Markdown разметке:_ \ref anchor_1
 * \arg _Сломанная ссылка:_ \ref no_page "Эта ссылка никуда не ведет"
 * \arg _Ссылка на заголовок в том же файле с произвольным текстом:_ \ref h1_sec_0 "Первая секция документа"
 * \arg _Ссылка на произвольный якорь:_ \ref create_table "Посмотреть еще раз на таблицы" 
 * \arg _Также можно ссылаться на внешние ресурсы с помощью HTML:_ <a href="https://ru.wikipedia.org">Русская Википедия</a> 
 * 
 * С помощью команды \p \\see, можно делать красивые вставки, чтобы ссылаться на некоторый материал, описанный в другом месте.
 * \see \ref create_table "как создавать таблицы в документации"
 * 
 * Кроме того, на все обнаруженные объекты программы Doxygen генерирует автоматические ссылки. Обычно просто достаточно
 * использовать прототип объекта как есть вместе с символом решетки (подробности см. <a href="http://www.doxygen.nl/manual/autolink.html">здесь</a>).
 * 
 * \arg Глобальная переменная #globalVar и глобальная переменная #a.
 * \arg Глобальная функция #my_function().
 * \arg Глобальная функция с аргументами #do_something(void*,long).
 * \arg Глобальное перечисление #EStatus.
 * \arg Директива #M_PI.
 * \arg На определения типов ссылаться немного сложнее: ::family, ::my_family.
 * \arg Пространство имен #no_std
 * \arg Класс #no_std::File
 * \arg Метод класса #no_std::File::protected_operation(). Однако такие ссылки, как эта, очень некрасивые,\n
 * поэтому вы можете оформить их в виде произвольного текста: \link no_std::File::protected_operation() защищенный метод \endlink.
 * 
 * Кроме того, можно ссылаться на файлы. По умолчанию, все строки, которые содержат точку и которая стоит не в конце, интерпретируются
 * как имена файлов. Если Doxygen найдет этот файл при сканировании, то он разрешит ссылку \p \\ref на него. Например, мы
 * можем сослаться на этот файл так \ref hdr_3.h "ссылка на меня". Это ссылка будет идти не на файл с исходным кодом, а на
 * страницу документации, которую Doxygen для него сгенерировал.
 *
 * \paragraph h1_sec_sec_sec_sec_2 Вставка исходного кода в документацию
 * Чтобы сделать документацию еще более наглядной, в документацию можно вставлять код программы из файлов с исходными кодами.
 * Обычно такой прием используют, чтобы показывать примеры использования, либо пояснить сказанное на конкретном участке кода.
 * 
 * Чтобы вставить некоторый фрагмент в документацию, его нужно пометить специальными командами прямо в исходном тексте,
 * причем можно ограничивать вставляемый фрагмент. Чтобы кусок кода можно было вставить, необходимо настроить переменную
 * \p EXAMPLE_PATH в конфигурационном файле Doxygen для проекта.
 * 
 * Например, вот этот фрагмент мы сюда вставили из этого исходного файла.
 * \snippet hdr_3.h Пример
 * \snippet hdr_3.h Другой пример
 * 
 * Кроме того, есть возможность выборочно набирать фрагмент с помощью команд \p \\include, \p \\dontinclude, \p \\until, \p \\skip,
 * \p \\line, \p \\skipline. Рекомендуется такой подход исключительно для кода, оформленного в отдельных файлах, так как
 * маленькие куски из большого файла проще извлекать с помощью \p \\snippet.
 * 
 * \paragraph h1_sec_sec_sec_sec_3 Вставка изображений
 * Для вставки изображений используется команда \p \\image. Для документации в формате HTML формат изображений ограничивается
 * используемым браузером. Для LaTeX формат изображений должен поддерживаться используемым компилятором LaTeX. Для HTML
 * и для LaTeX документации формат команды \p \\image немного отличается.
 * 
 * Для включения возможности вставки изображений вы должны настроить переменную \p IMAGE_PATH.
 * \image html ruwiki.png Рисунок с оригинальным размером
 * \image html ruwiki.png Рисунок с уменьшенным размером width=80
 * 
 * \paragraph h1_sec_sec_sec_sec_4 Информационные блоки
 * В Doxygen есть много способов особым образом выделить некоторые абзацы.
 * \verbatim Эта строка передана как есть. \endverbatim
 * \remark Текст примечания.
 * \note Текст заметки.
 * \bug Текст известной ошибки.
 * \warning Текст предупреждения.
 * \attention Текст замечания.
 * \todo Текст того, что предстоит сделать.
 * \test Текст описания сценария тестирования.
 * \deprecated Текст описания устаревшей функциональности.
 * 
 * \paragraph h1_sec_sec_sec_sec_5 Вывод списков в несколько колонок
 * Для вывода списка в несколько колонок вы можете применить класс CSS-стиля \p multicol, который генерирует Doxygen.
 * На его основе удобно составлять многоколоночные указатели. Класс стремится упаковать список в три колонки.
 * <hr>
 * <div>
 *   <ul class="multicol">
 *       <li>Пункт 1</li>
 *       <li>Пункт 2</li>
 *       <li>Пункт 3</li>
 *       <li>Пункт 4</li>
 *       <li>Пункт 5</li>
 *       <li>Пункт 6</li>
 *   </ul>
 * </div>
 * <hr>
 * 
 * \section h1_sec_2 Удаленное документирование
 * Существует подход документирования исходных кодов, при котором комментарии Doxygen пишутся в
 * удалении от объявления программных объектов.
 * Обычно такой подход используется для языка C, чтобы не захламлять комментариями
 * исходный код. Другой вариант, когда код еще не дописан и часто переписывается, чтобы держать
 * комментарии в одном месте, как черновик.
 * 
 * При удаленном документировании нужно выбрать в какой части файла
 * писать комментарии Doxygen. Вы делаете также, как если бы комментировали непосредственно
 * рядом с кодом, но указываете комментируемую часть кода прямо в комментарии.
 * Для этого необходимо использовать команды \p \\fn, \p \\typedef, \p \\var, \p \\property, \p \\var,
 * \p \\class, \p \\union, \p \\def, \p \\pure, \p \\relates, \p \\public, \p \\protected, \p \\private,
 * \p \\memberof, \p \\publicsection, \p \\protectedsection, \p \\privatesection, \p \\implements.
 * 
 * Для примера, мы задокументируем код, который находится в самом низу этого файла.
 * 
 * @authors Симпсон, Гомер<br>
 *          Дак, Дональд
 * @copyright Текст вашего копирайта
 */

/**
 * @class Event
 * @brief Класс хранения события мыши.
 * 
 * @enum Event::EventType
 * @brief Тип события.
 * 
 * @var Event::EventType Event::MOUSE_PRESS
 * @brief Нажатие кнопки мыши
 *
 * @var Event::EventType Event::MOUSE_RELEASE
 * @brief Отпускание кнопки мыши
 *
 * @var Event::EventType Event::KEYBOARD_PRESS
 * @brief Нажатие кнопки на клавиатуре
 *
 * @var Event::EventType Event::KEYBOARD_RELEASE
 * @brief Отпускание клавиши на клавиатуре
 * 
 * @class Event::MouseEvent
 * @brief Структура для хранения координат курсора мыши.
 * 
 * @var Event::MouseEvent::x
 * @brief Координата в горизонтальной плоскости экрана.
 * 
 * @var Event::MouseEvent::y
 * @brief Координата в вертикальной плоскости экрана.
 * 
 * @class Event::KeyboardEvent
 * @brief Событие клавиатуры.
 * 
 * @var Event::KeyboardEvent::scancode
 * @brief Код клавиши.
 * 
 * @var Event::KeyboardEvent::virtualKey
 * @brief Идентификатор клавиши.
 * 
 * @var Event::type
 * @brief Тип события.
 * 
 * @def MAXI(a,b)
 * @brief Макрос возвращает максимальное значение между \a a и \a b.
 * 
 * Детальное описание макроса.
 *
 * @var typedef unsigned int USHRT
 * @brief Определения типа для \a unsigned short.
 * 
 * Детальное описание для переменной.
 *
 * @var int errno_1
 * @brief Хранит последний код ошибки.
 * 
 * @warning Не потокобезопасна.
 *
 * @fn int lib_open(const char *path, int flags)
 * @brief Открывает файловый дескриптор.
 * 
 * @param path Путь к файлу в файловой системе.
 * @param flags Флаги, с которыми открывается дескриптор.
 *
 * @fn int lib_close(int fd)
 * @brief Закрывает открытый ранее файловый декскриптор \a fd.
 * @param fd Номер файлового дескриптора.
 *
 * @fn size_t lib_write(int fd, const char *buf, size_t count)
 * @brief Записывает \a count байт из буфера \a buf в файл, связанный
 * с дескриптором \a fd.
 * @param fd Файловый дескриптор.
 * @param buf Указатель на буфер - источник данных.
 * @param count Размер буфера для записи.
 * @return Количество записанных байт
 *
 * @fn int lib_read(int fd,char *buf,size_t count)
 * @brief Читает данные из файла, связанного с файловым дескриптором.
 * @param fd Файловый дескриптор.
 * @param buf Указатель на буфер, в который данные будут записаны.
 * @param count Сколько байт должно быть прочитано из буфера.
 * @return Количество прочитанных байт.
 */

/**
 * @brief Краткое описание для переменной.
 * 
 * Это первый способ описания переменной в месте ее объявления. К недостатку такого стиля
 * можно отнести то, что он занимает много места, но с другой стороны получается наглядно.
 * 
 * @note Никогда не оставляйте пустых строк между комментируемым объектом программы и комментарием
 * Doxygen.
 */
int a = 10;

//! Краткое описание переменной.
/*! Второй способ описать объект. К преимуществам данного метода комментирования можно отнести
 * его компактность. Его рекомендуется применять внутри классов и структур. 
 */
int globalVar = 5;

//! Краткое описание функции.
/*! Детальное описание функции
    в несколько
    строк.                     */
void my_function();

/**
 * @brief Краткое описание функции с аргументами.
 * 
 * Эта функция что-то делает.
 * 
 * @param data Указатель на данные.
 * @param flags Флаги, изменяющие поведение процедуры.
 * @return true в случае успеха. 
 * @return false в случае провала.
 */
bool do_something(void* data, long flags);

//! Краткое описание структуры.
//! Структура, описывающая семью.
typedef struct family_t {
    char* mom;          //!< Указатель на мать.  
    char* dad;          //!< Указатель на отца.
    char* children;     //!< Указатель на детей.
                        //!< \note Дети разделяются через запятую.
} family;

//! Статус операции.
enum EStatus {
    etSUCCESS       = 0, //!< Признак успешности операции.
    etFAIL,              //!< Признак провала операции.
    etCRITICAL_FAIL = 16 //!< Признак критического провала операции.
};

//! Краткое описание директивы.
#define M_PI 3.1415

//! Псевдоним.
using my_family = family_t;

//! Краткое описание пространства имен.
namespace no_std {
    //! Краткое описание класса.
    /*! Обратите внимание на то, что рекомендуется использовать самый короткий стиль оформления
        комментариев для описания классов. По возможности следует избегать явного использования команд
        Doxygen, потому что в некоторых редакторах исходного кода они попадают в сплывающие подсказки
        и мешают.

        Требование короткого стиля главным образом связано с тем, что в лишнем тексте теряется исходный код класса, и
        программисту становится сложнее понять его.
    */
    class File {
        public:
            //! Статус объекта.
            enum status {
                UNKNOWN = 0, //!< Неопределенное
                OPENED,      //!< Открыт и готов к чтению
                CLOSED,      //!< Закрыт
                IN_USE       //!< В данный момент где-то используется
            };
            
            explicit File() =default;   //!< Стандартный конструктор.
            virtual ~File() =default;   //!< Стандартный деструктор.

            //! Открытая операция
            /*! 
                Что-то делает.
                @param str Строка.
                @return Какой-то код.
            */
            int public_operation(char* str);
            //! Возвращает статус файла. \see File::status
            status status();
        protected:
            //! Защищенный виртуальный метод.
            virtual void protected_operation() {}

            //! Защищенный член класса.
            int m_prot_var;
        private:
            //! Приватный метод.
            //! @param arg Какой-то аргумент.
            //! @return Какой-то код.
            int private_operation(int arg);

            int m_priv_var; //!< Приватный член класса.
    };
}

//! Эта функция будет вставлена в документацю целиком. Мы используем команду \p \\noop , чтобы текст метки не попал в выдачу.
//! \noop [Пример]
int function_for_snippet(int counter, int arg) {
    if (counter <= 0) {
        counter = 10;
    }

    while (counter--) {
        arg++;
    }

    return arg;
}
//! Часть этой функции будет вставлена в документацию.
//! \noop [Пример]
int function_for_snippet_1() {
//! \noop [Другой пример]
    for (int i = 0; i < 10 ; i++)
    {
        // Код программы
    }
//! \noop [Другой пример]
}

#define MAXI(a,b) (((a)>(b))?(a):(b))

typedef unsigned short USHRT;
int errno_1;
int lib_open(const char *,int);
int lib_close(int);
size_t lib_write(int,const char *, size_t);
int lib_read(int,char *,size_t);

struct Event
{
    enum EventType {
        MOUSE_PRESS,
        MOUSE_RELEASE,
        KEYBOARD_PRESS,
        KEYBOARD_RELEASE,
    };

    struct MouseEvent {
        unsigned x;
        unsigned y;
    };

    struct KeyboardEvent {
        unsigned scancode;
        unsigned virtualKey;
    };

    EventType type;
    union {
        MouseEvent mouse;
        KeyboardEvent keyboard;
    };
};