/**
 * @file hdr_2.h
 * @author Джон Доу (john@example.com)
 * @brief В этом исходном файле рассмотрены возможности группировки документируемого материала
 * @version 0.1
 * @date 2020-02-21
 * @copyright Copyright (c) 2020
 * @ingroup ifaces
 * 
 * Doxygen использует три способа группировки всего вместе:
 *  -# Первый способ это создание новой страницы для новой "группы", которая в терминах Doxygen называется модулем.
 *  -# Второй способ это группировка в пределах существующего модуля.
 *  -# Для страниц третий способ использует создание подстраниц.
 * 
 * ## Модули
 * Модули позволяют разбивать весь материал на отдельные страницы. Любой модуль состоит хотя бы из одной подгруппы:
 * файлов, пространств имен, классов, функций, переменных, перечислений, определений типов, макросов, а также уже
 * сгруппированных подобным образом подгрупп.
 * 
 * Ниже в этом файле демонстрируется как делается группировка.
 * 
 * _Для групп действуют следующие правила:_
 *   -# Классы, пространства имен и файлы могут быть членами нескольких групп.
 *   -# Переменные, функции, новые типы и перечисления могут быть членами только одной группы.
 * 
 * На любые группы, если они существуют, можно сослаться по внутренним ссылкам из любого места документации.
 * Например так: \ref ifaces "Ссылка на общие интерфейсы".
 * 
 */

/*=********************************************************************************
 * ОБЪЯВЛЕНИЕ ГРУППЫ, ДОБАВЛЕНИЕ В ГРУППУ
 *********************************************************************************/

/** @defgroup ifaces Общие интерфейсы
 *  Первая группа
 *  @{
 */

/**
 * @brief Краткое описание нового пространства имен
 * 
 */
namespace NewSpace {
    /**
     * @brief Краткое описание интерфейса
     * 
     */
    class NewInterface {
    public:
        virtual ~NewInterface() = default;

        virtual int open(const char *,int) =0;             //!< Открыть файл для чтения.
        virtual int close(int) =0;                         //!< Закрыть ранее открытый файл.
        virtual int write(int,const char *, size_t) =0;    //!< Записать в файл данные.
        virtual int read(int,char *,size_t) =0;            //!< Прочитать из файла данные.
    };

    /**
     * @brief Краткое описание второго интерфейса
     * 
     */
    class Command {
    public:
        virtual ~Command() = default;

        virtual bool execute() =0;   //!< Исполнить команду
        virtual bool undo()    =0;   //!< Отменить команду
    };
} // NewSpace
/** @}*/

/*=********************************************************************************
 * ... ЕСЛИ БЫ СЛЕДУЮЩИЙ КЛАСС ЛЕЖАЛ БЫ В ДРУГОМ ФАЙЛЕ, ТО ЕГО МОЖНО БЫЛО БЫ
 *     ДОБАВИТЬ В ГРУППУ ТАК ...
 * 
 * Примечание:
 *   Если группы с указанным лейблом не существует, то она будет создана командой
 *   @addtogroup. Нельзя добавлять новых членов с помощью @defgroup.
 * 
 *********************************************************************************/

/** @addtogroup ifaces
 *  @{
 */
namespace NewSpace {
    /**
     * @brief Краткое описание третьего интерфейса
     * 
     */
    class Builder {
    public:
        virtual ~Builder() = default;

        virtual bool build()   =0;           //!< Построить
        virtual void getResult(void*) =0;    //!< Забрать результат
    };
}
/** @}*/

/*=********************************************************************************
 * Вы можете использовать команду @ingroup в комментариях классов и пространств
 * имен, чтобы добавить их в группу.
 *********************************************************************************/
/**
 * @brief Краткое описание пространства имен.
 * @ingroup ifaces
 */
namespace OtherSpace {
    /**
     * @brief Краткое описание еше одного интерфейса.
     * @ingroup ifaces
     * 
     */
    class Builder_1 {
        public:
        virtual ~Builder_1() = default;

        virtual bool build(int,int)   =0;    //!< Построить
        virtual void getResult(void*) =0;    //!< Забрать результат
    };
} // OtherSpace

/**
 * @defgroup global_vars Глобальные переменные
 * @brief Глобальные переменные
 * 
 * Смотрите также \ref global_funcs "Глобальные функции".
 * 
 * @{
 */

const float VAR = 3.1415;  //!< Какая-то переменная

/** @}*/

/**
 * @defgroup global_funcs Глобальные функции
 * @brief Глобальные функции
 * 
 * Смотрите также \ref global_vars "Глобальные переменные".
 * 
 * @{
 */

/**
 * @brief Краткое описание функции.
 * 
 * @section myfunc_sec_1 Секция в описании
 * Строка в секции. 
 */
void myfunc();

/** @}*/

/*=********************************************************************************
 * ДОПОЛНИТЕЛЬНАЯ ГРУППИРОВКА
 * 
 * Doxygen, основываясь на семантике языка программирования, автоматически
 * группирует все составляющие объекта документирования. Однако, вы вольны
 * делать свою собственную перегруппировку, если вам кажется, что стандартная
 * группировка делает что-то неправильно.
 * 
 * Для этого вы можете использовать блоки
 * ///@{
 * ///@}
 * 
 * По умолчанию группировка для классов работает так:
 *  1. Если все члены группы одного типа и имеют одинаковую видимость, то они
 *     будут сгруппированы по типу видимости (public,private,protected).
 *  2. Если члены группы лежат в статичной памяти, то они будут также
 *     дополнительно сгруппированы.
 *  3. Все элементы разного типа укладываются в автоматически генерируемых
 *     группах, которые лежат на одном уровне.
 * 
 *********************************************************************************/

/** @defgroup mygroup Моя группа
 *  Детальное описание моей группы.
 *  @{
 */

/** Краткое описание. Детальное описание. */
class NewClass {
    public:
        ///@{
        /** Это описание используется для всех методов. Этот прием вы можете использовать
         * для перегруженных функций. */
        void func1InGroup1();
        void func2InGroup1();
        void func3InGroup1();
        void func4InGroup1();
        ///@}

        /** Эта функция не принадлежит никакой группе. Детали */
        void ungrouped();
        void func1InGroup2();
    protected:
        void func2InGroup2();
};
void NewClass::func1InGroup1() {}
void NewClass::func2InGroup1() {}
void NewClass::func3InGroup1() {}
void NewClass::func4InGroup1() {}

/** @name Группа 2
 *  Описание второй группы.
 */
///@{
/** Описание первой функции второй группы. Детали. */
void NewClass::func1InGroup2() {}
/** Описание второй функции второй группы. Детали. */
void NewClass::func2InGroup2() {}
///@}

/** @}*/

///@{
/**
 * Общее описание для всех членов этой группы.
 */
//! Какой-то макрос 1
#define A 1
//! Какой-то макрос 2
#define B 2
//! Какая-то функция
void gFunction();
///@}

/*=********************************************************************************
 * РАЗБИЕНИЕ НА ПОДСТРАНИЦЫ
 * 
 * Вы можете разбивать содержимое на подстраницы, используя команду @page.
 * Если вы используете Markdown страницы, то помните, что первый лейбл на странице
 * не должен совпадать с метками, которые вы используете в комментариях Doxygen,
 * иначе эти страницы будут неправильно перемешаны: обычно Markdown страницы прикрепляются
 * книзу, обрезая первый заголовок.
 * 
 * Помните, что лэйблы для секций, введенные вручную, не должны совпадать во всем
 * проекте. Рекомендуется использовать такой формат:
 * 
 *  <имя файла><имя страницы>_(section|subsection)
 * 
 *********************************************************************************/

/** @page page_1 Страница документации 1
 * @tableofcontents
 * Этот текст написан на странице документации номер 1. Теперь вы знаете о разбиении
 * на подстраницы почти все.
 * 
 * Новая строка.
 * @section sec_1 Раздел на странице 1
 * Этот текст лежит в разделе 1. Вы можете ссылаться на разделы одной страницы: \ref sub_1 "Подраздел 1"
 * \ref sub_2 "Подраздел 2".
 * @subsection sub_1 Подраздел 1
 * Этот текст лежит в подразделе 1.
 * @subsection sub_2 Подраздел 2
 * Этот текст лежит в подразделе 2.
 * 
 * @subsection sub_3 Формулы
 * Формулы могут быть вставлены тремя способами:
 *  -# Формулы, вставленные между символами в одной строке.
 *  -# Формулы, вставленные на собственную строку и выравненные по середине.
 *  -# Третий способ похож на второй, но вы можете указать LaTeX-окружение самостоятельно.
 * 
 * Расстояние между точками \f$(x_1,y_1)\f$ и \f$(x_2,y_2)\f$ может быть вычеслено по формуле
 * \f$\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}\f$.
 * 
 * LaTeX формула:
 * \f[ 
 *   |I_2|=\left| \int_{0}^T \psi(t) 
 *         \left\{ 
 *            u(a,t)
 *            \int_{\gamma(t)}^a 
 *            \frac{d\theta}{k(\theta,t)} 
 *            \int_{a}^\theta c(\xi)u_t(\xi,t)\,d\xi
 *         \right\} dt 
 *      \right| 
 * \f]
 * 
 * Еще формула:
 * \f{eqnarray*}{ 
 *        g &=& \frac{Gm_2}{r^2} \\ 
 *          &=& \frac{(6.673 \times 10^{-11}\,
 *              \mbox{m}^3\,\mbox{kg}^{-1}\, \mbox{s}^{-2})(5.9736 \times 10^{24}\,\mbox{kg})}{(6371.01\,\mbox{km})^2} \\
 *          &=& 9.82066032\,\mbox{m/s}^2
 * \f}
 * 
 * @subsubsection subsub_1 Самая нижняя секция
 * @paragraph prgph_1 Параграф
 * @remark Текст примечания.
 * @bug Текст ошибки.
 * @note Текст заметки.
 * @attention Текст предупреждения.
 * @deprecated Текст устаревшей функциональности.
 */

/** @page page_2 Страница документации 2
 * Пишите, что хотите.
 */

/*=********************************************************************************
 * ПЕРЕОПРЕДЕЛЕНИЕ ОСНОВНОЙ СТРАНИЦЫ
 * 
 * Вы можете переопределить основную страницу, используя тег @mainpage.
 * Чтобы посмотреть результат, перед генерацией замените символ '=' на '*' в
 * следующем комментарии.
 * 
 * Мы не используем эту секцию сейчас, потому что в проекте есть страница intro.md на Markdown,
 * которая будет перекрыта этой секцией. Страница intro.md будет автоматически подхвачена
 * генератором.
 * 
 *********************************************************************************/

/*= @mainpage Моя страница с индексом
 * @section intro Введение
 * Это введение
 * @section install Установка
 * Здесь описано как установить проект.
 * @subsection step_1 Шаг 1
 * Описание первого шага.
 */